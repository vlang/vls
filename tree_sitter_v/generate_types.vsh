import json
import strings

/*

This is a script file which creates static type declarations
for tree-sitter-v's node types by using the information found
in node-types.json and turn it into a pseudo-sum type using enums
and create a NodeTypeFactory implementation that will convert type names
into respective NodeType enum. Anonymous nodes are automatically identified
as NodeType.unknown.

See: https://tree-sitter.github.io/tree-sitter/using-parsers#static-node-types

*/

struct NodeType {
	name     string [json:'type']
	named    bool
	subtypes []NodeType
	// children TypeChildren
}

// struct TypeChildren {
// 	multiple bool
// 	required bool
// 	types    []NodeType
// }

fn (ntype NodeType) is_anon() bool {
	return !ntype.named || ntype.name.len == 0 || ntype.name[0] == `_`
}

to_be_escaped := ['none', 'true', 'false', 'map']
cur_dir := dir(@FILE)
node_types_json := read_file(join_path(cur_dir, 'src', 'node-types.json'))?
node_types := json.decode([]NodeType, node_types_json)?
node_type_enum_name := 'NodeType'
mut file := open_file(join_path(cur_dir, 'node_types.v'), 'w+')?
mut wr := strings.new_builder(1024 * 1024)

wr.writeln('module tree_sitter_v\n')
wr.writeln('/* This is an auto-generated file. Do not edit this file directly! See `generate_types.vsh` */')

// write supertypes
// wr.writeln('pub enum SuperType {')
// for ntype in node_types {
// 	if !ntype.named || ntype.name.len == 0 || ntype.name[0] != `_` {
// 		continue
// 	}

// 	wr.writeln('\t$ntype.name')
// }
// wr.writeln('}\n')

wr.writeln('pub enum $node_type_enum_name {')
wr.writeln('\tunknown\n\terror')

mut declaration_node_types := []string{cap: 100}
mut identifier_node_types := []string{cap: 100}
mut literal_node_types := []string{cap: 100}

// write node types as enum members
for ntype in node_types {
	if ntype.is_anon() {
		continue
	}

	if ntype.name.ends_with('_declaration') {
		declaration_node_types << ntype.name
	} else if ntype.name == 'identifier' || ntype.name.ends_with('_identifier') {
		identifier_node_types << ntype.name
	} else if ntype.name.ends_with('_literal') {
		literal_node_types << ntype.name
	}

	wr.write_string('\t$ntype.name')
	if ntype.name in to_be_escaped {
		wr.write_u8(`_`)
	}
	wr.write_u8(`\n`)
}
wr.writeln('}')

// write declaration list node types const
wr.writeln('\nconst declaration_node_types = [')
for i, ntype_name in declaration_node_types {
	wr.write_u8(`\t`)
	if i == 0 {
		wr.write_string(node_type_enum_name)
	}
	wr.write_string('.$ntype_name')
	if i < declaration_node_types.len - 1 {
		wr.write_u8(`,`)
	}
	wr.write_u8(`\n`)
}
wr.writeln(']')

// write identifier list node types const
wr.writeln('\nconst identifier_node_types = [')
for i, ntype_name in identifier_node_types {
	wr.write_u8(`\t`)
	if i == 0 {
		wr.write_string(node_type_enum_name)
	}
	wr.write_string('.$ntype_name')
	if i < identifier_node_types.len - 1 {
		wr.write_u8(`,`)
	}
	wr.write_u8(`\n`)
}
wr.writeln(']')

// write literal list node types const
wr.writeln('\nconst literal_node_types = [')
for i, ntype_name in literal_node_types {
	wr.write_u8(`\t`)
	if i == 0 {
		wr.write_string(node_type_enum_name)
	}
	wr.write_string('.$ntype_name')
	if i < literal_node_types.len - 1 {
		wr.write_u8(`,`)
	}
	wr.write_u8(`\n`)
}
wr.writeln(']')

wr.writeln('\npub fn (typ $node_type_enum_name) is_declaration() bool { return typ in declaration_node_types }')
wr.writeln('pub fn (typ $node_type_enum_name) is_identifier() bool { return typ in identifier_node_types }')
wr.writeln('pub fn (typ $node_type_enum_name) is_literal() bool { return typ in literal_node_types }')

// create VNodeTypeFactory
node_type_factory_sym_name := 'VNodeTypeFactory'

wr.writeln('\npub const type_factory = &$node_type_factory_sym_name{}')
wr.writeln('\npub struct $node_type_factory_sym_name {}')
wr.writeln('\npub fn (nf $node_type_factory_sym_name) get_type(type_name string) $node_type_enum_name {')
wr.writeln('\treturn match type_name {')
wr.writeln("\t\t'ERROR' { ${node_type_enum_name}.error }")

for ntype in node_types {
	if ntype.is_anon() {
		continue
	}

	wr.write_string("\t\t'$ntype.name' { ${node_type_enum_name}.")
	wr.write_string(ntype.name)
	if ntype.name in to_be_escaped {
		wr.write_u8(`_`)
	}
	wr.writeln(' }')
}
wr.writeln('\t\t else { ${node_type_enum_name}.unknown }')
wr.writeln('\t}')
wr.writeln('}')

file.write(wr)?
file.close()
