module tree_sitter_v
import arrays { merge }

/* This is an auto-generated file. Do not edit this file directly! See `generate_types.vsh` */
pub enum SuperType {
	unknown
	expression
	expression_with_blocks
	simple_statement
	simple_type
	statement
	top_level_declaration
	type_
}

pub enum NodeType {
	unknown
	error
	argument_list
	array
	array_type
	as_type_cast_expression
	asm_statement
	assert_statement
	assignment_statement
	attribute_declaration
	attribute_list
	attribute_spec
	binary_expression
	binded_identifier
	binded_type
	block
	break_statement
	builtin_type
	c_string_literal
	call_expression
	case_list
	channel_type
	comment
	comptime_for_statement
	comptime_identifier
	comptime_if_expression
	comptime_selector_expression
	const_declaration
	const_spec
	continue_statement
	cstyle_for_clause
	dec_statement
	default_case
	defer_statement
	element
	empty_literal_value
	enum_declaration
	enum_member
	enum_member_declaration_list
	exposed_variables_list
	expression_case
	expression_list
	fixed_array
	fixed_array_type
	fn_literal
	for_in_operator
	for_statement
	format_specifier
	function_declaration
	function_type
	generic_type
	global_var_declaration
	global_var_spec
	global_var_type_initializer
	go_statement
	goto_statement
	hash_statement
	identifier_list
	if_expression
	import_alias
	import_declaration
	import_symbols
	import_symbols_list
	inc_statement
	index_expression
	interface_declaration
	interface_field_scope
	interface_spec
	interface_spec_list
	interpreted_string_literal
	is_expression
	keyed_element
	labeled_statement
	literal_value
	lock_expression
	map_
	map_type
	match_expression
	module_clause
	multi_return_type
	mutable_expression
	mutable_identifier
	option_propagator
	option_type
	or_block
	overloadable_operator
	parameter_declaration
	parameter_list
	parenthesized_expression
	pointer_type
	pseudo_comptime_identifier
	qualified_type
	range
	raw_string_literal
	return_statement
	select_branch
	select_default_branch
	select_expression
	selector_expression
	send_statement
	shared_type
	short_var_declaration
	slice_expression
	source_file
	special_argument_list
	special_call_expression
	spread_operator
	sql_expression
	string_interpolation
	struct_declaration
	struct_field_declaration
	struct_field_declaration_list
	struct_field_scope
	thread_type
	type_cast_expression
	type_declaration
	type_initializer
	type_list
	type_only_parameter_list
	type_parameter_declaration
	type_parameters
	type_selector_expression
	unary_expression
	unsafe_expression
	variadic_type
	escape_sequence
	false_
	field_identifier
	float_literal
	identifier
	import_path
	int_literal
	label_name
	module_identifier
	none_
	rune_literal
	true_
	type_identifier
	type_placeholder
}

const supertype__expression_nodes = merge(supertype__expression_with_blocks_nodes, [
	NodeType.array,
	.as_type_cast_expression,
	.binary_expression,
	.binded_identifier,
	.c_string_literal,
	.call_expression,
	.empty_literal_value,
	.false_,
	.fixed_array,
	.float_literal,
	.fn_literal,
	.identifier,
	.index_expression,
	.int_literal,
	.interpreted_string_literal,
	.is_expression,
	.map_,
	.none_,
	.parenthesized_expression,
	.pseudo_comptime_identifier,
	.raw_string_literal,
	.rune_literal,
	.selector_expression,
	.slice_expression,
	.special_call_expression,
	.true_,
	.type_cast_expression,
	.type_initializer,
	.type_selector_expression,
	.unary_expression
])

const supertype__expression_with_blocks_nodes = [
	NodeType.comptime_if_expression,
	.if_expression,
	.lock_expression,
	.match_expression,
	.select_expression,
	.sql_expression,
	.unsafe_expression
]

const supertype__simple_statement_nodes = merge(supertype__expression_nodes, [
	NodeType.assignment_statement,
	.dec_statement,
	.inc_statement,
	.short_var_declaration
])

const supertype__simple_type_nodes = [
	NodeType.array_type,
	.binded_type,
	.builtin_type,
	.channel_type,
	.fixed_array_type,
	.function_type,
	.generic_type,
	.map_type,
	.pointer_type,
	.qualified_type,
	.shared_type,
	.thread_type,
	.type_identifier,
	.type_placeholder
]

const supertype__statement_nodes = merge(supertype__simple_statement_nodes, [
	NodeType.asm_statement,
	.assert_statement,
	.block,
	.break_statement,
	.comptime_for_statement,
	.continue_statement,
	.defer_statement,
	.for_statement,
	.go_statement,
	.goto_statement,
	.hash_statement,
	.labeled_statement,
	.return_statement,
	.send_statement
])

const supertype__top_level_declaration_nodes = [
	NodeType.const_declaration,
	.enum_declaration,
	.function_declaration,
	.global_var_declaration,
	.import_declaration,
	.interface_declaration,
	.module_clause,
	.struct_declaration,
	.type_declaration
]

const supertype__type_nodes = merge(supertype__simple_type_nodes, [
	NodeType.multi_return_type,
	.option_type
])

pub fn (typ NodeType) group() SuperType {
	return if typ in supertype__top_level_declaration_nodes {
		SuperType.top_level_declaration
	} else if typ in supertype__statement_nodes {
		SuperType.statement
	} else if typ in supertype__simple_statement_nodes {
		SuperType.simple_statement
	} else if typ in supertype__expression_nodes {
		SuperType.expression
	} else if typ in supertype__expression_with_blocks_nodes {
		SuperType.expression_with_blocks
	} else if typ in supertype__type_nodes {
		SuperType.type_
	} else if typ in supertype__simple_type_nodes {
		SuperType.simple_type
	} else {
		SuperType.unknown
	}
}

const declaration_node_types = [
	NodeType.attribute_declaration,
	.const_declaration,
	.enum_declaration,
	.function_declaration,
	.global_var_declaration,
	.import_declaration,
	.interface_declaration,
	.parameter_declaration,
	.short_var_declaration,
	.struct_declaration,
	.struct_field_declaration,
	.type_declaration,
	.type_parameter_declaration
]

const identifier_node_types = [
	NodeType.binded_identifier,
	.comptime_identifier,
	.mutable_identifier,
	.pseudo_comptime_identifier,
	.field_identifier,
	.identifier,
	.module_identifier,
	.type_identifier
]

const literal_node_types = [
	NodeType.c_string_literal,
	.fn_literal,
	.interpreted_string_literal,
	.raw_string_literal,
	.float_literal,
	.int_literal,
	.rune_literal
]

pub fn (typ NodeType) is_declaration() bool { return typ in declaration_node_types }
pub fn (typ NodeType) is_identifier() bool { return typ in identifier_node_types }
pub fn (typ NodeType) is_literal() bool { return typ in literal_node_types }

pub const type_factory = &VNodeTypeFactory{}

pub struct VNodeTypeFactory {}

pub fn (nf VNodeTypeFactory) get_type(type_name string) NodeType {
	return match type_name {
		'ERROR' { NodeType.error }
		'argument_list' { NodeType.argument_list }
		'array' { NodeType.array }
		'array_type' { NodeType.array_type }
		'as_type_cast_expression' { NodeType.as_type_cast_expression }
		'asm_statement' { NodeType.asm_statement }
		'assert_statement' { NodeType.assert_statement }
		'assignment_statement' { NodeType.assignment_statement }
		'attribute_declaration' { NodeType.attribute_declaration }
		'attribute_list' { NodeType.attribute_list }
		'attribute_spec' { NodeType.attribute_spec }
		'binary_expression' { NodeType.binary_expression }
		'binded_identifier' { NodeType.binded_identifier }
		'binded_type' { NodeType.binded_type }
		'block' { NodeType.block }
		'break_statement' { NodeType.break_statement }
		'builtin_type' { NodeType.builtin_type }
		'c_string_literal' { NodeType.c_string_literal }
		'call_expression' { NodeType.call_expression }
		'case_list' { NodeType.case_list }
		'channel_type' { NodeType.channel_type }
		'comment' { NodeType.comment }
		'comptime_for_statement' { NodeType.comptime_for_statement }
		'comptime_identifier' { NodeType.comptime_identifier }
		'comptime_if_expression' { NodeType.comptime_if_expression }
		'comptime_selector_expression' { NodeType.comptime_selector_expression }
		'const_declaration' { NodeType.const_declaration }
		'const_spec' { NodeType.const_spec }
		'continue_statement' { NodeType.continue_statement }
		'cstyle_for_clause' { NodeType.cstyle_for_clause }
		'dec_statement' { NodeType.dec_statement }
		'default_case' { NodeType.default_case }
		'defer_statement' { NodeType.defer_statement }
		'element' { NodeType.element }
		'empty_literal_value' { NodeType.empty_literal_value }
		'enum_declaration' { NodeType.enum_declaration }
		'enum_member' { NodeType.enum_member }
		'enum_member_declaration_list' { NodeType.enum_member_declaration_list }
		'exposed_variables_list' { NodeType.exposed_variables_list }
		'expression_case' { NodeType.expression_case }
		'expression_list' { NodeType.expression_list }
		'fixed_array' { NodeType.fixed_array }
		'fixed_array_type' { NodeType.fixed_array_type }
		'fn_literal' { NodeType.fn_literal }
		'for_in_operator' { NodeType.for_in_operator }
		'for_statement' { NodeType.for_statement }
		'format_specifier' { NodeType.format_specifier }
		'function_declaration' { NodeType.function_declaration }
		'function_type' { NodeType.function_type }
		'generic_type' { NodeType.generic_type }
		'global_var_declaration' { NodeType.global_var_declaration }
		'global_var_spec' { NodeType.global_var_spec }
		'global_var_type_initializer' { NodeType.global_var_type_initializer }
		'go_statement' { NodeType.go_statement }
		'goto_statement' { NodeType.goto_statement }
		'hash_statement' { NodeType.hash_statement }
		'identifier_list' { NodeType.identifier_list }
		'if_expression' { NodeType.if_expression }
		'import_alias' { NodeType.import_alias }
		'import_declaration' { NodeType.import_declaration }
		'import_symbols' { NodeType.import_symbols }
		'import_symbols_list' { NodeType.import_symbols_list }
		'inc_statement' { NodeType.inc_statement }
		'index_expression' { NodeType.index_expression }
		'interface_declaration' { NodeType.interface_declaration }
		'interface_field_scope' { NodeType.interface_field_scope }
		'interface_spec' { NodeType.interface_spec }
		'interface_spec_list' { NodeType.interface_spec_list }
		'interpreted_string_literal' { NodeType.interpreted_string_literal }
		'is_expression' { NodeType.is_expression }
		'keyed_element' { NodeType.keyed_element }
		'labeled_statement' { NodeType.labeled_statement }
		'literal_value' { NodeType.literal_value }
		'lock_expression' { NodeType.lock_expression }
		'map' { NodeType.map_ }
		'map_type' { NodeType.map_type }
		'match_expression' { NodeType.match_expression }
		'module_clause' { NodeType.module_clause }
		'multi_return_type' { NodeType.multi_return_type }
		'mutable_expression' { NodeType.mutable_expression }
		'mutable_identifier' { NodeType.mutable_identifier }
		'option_propagator' { NodeType.option_propagator }
		'option_type' { NodeType.option_type }
		'or_block' { NodeType.or_block }
		'overloadable_operator' { NodeType.overloadable_operator }
		'parameter_declaration' { NodeType.parameter_declaration }
		'parameter_list' { NodeType.parameter_list }
		'parenthesized_expression' { NodeType.parenthesized_expression }
		'pointer_type' { NodeType.pointer_type }
		'pseudo_comptime_identifier' { NodeType.pseudo_comptime_identifier }
		'qualified_type' { NodeType.qualified_type }
		'range' { NodeType.range }
		'raw_string_literal' { NodeType.raw_string_literal }
		'return_statement' { NodeType.return_statement }
		'select_branch' { NodeType.select_branch }
		'select_default_branch' { NodeType.select_default_branch }
		'select_expression' { NodeType.select_expression }
		'selector_expression' { NodeType.selector_expression }
		'send_statement' { NodeType.send_statement }
		'shared_type' { NodeType.shared_type }
		'short_var_declaration' { NodeType.short_var_declaration }
		'slice_expression' { NodeType.slice_expression }
		'source_file' { NodeType.source_file }
		'special_argument_list' { NodeType.special_argument_list }
		'special_call_expression' { NodeType.special_call_expression }
		'spread_operator' { NodeType.spread_operator }
		'sql_expression' { NodeType.sql_expression }
		'string_interpolation' { NodeType.string_interpolation }
		'struct_declaration' { NodeType.struct_declaration }
		'struct_field_declaration' { NodeType.struct_field_declaration }
		'struct_field_declaration_list' { NodeType.struct_field_declaration_list }
		'struct_field_scope' { NodeType.struct_field_scope }
		'thread_type' { NodeType.thread_type }
		'type_cast_expression' { NodeType.type_cast_expression }
		'type_declaration' { NodeType.type_declaration }
		'type_initializer' { NodeType.type_initializer }
		'type_list' { NodeType.type_list }
		'type_only_parameter_list' { NodeType.type_only_parameter_list }
		'type_parameter_declaration' { NodeType.type_parameter_declaration }
		'type_parameters' { NodeType.type_parameters }
		'type_selector_expression' { NodeType.type_selector_expression }
		'unary_expression' { NodeType.unary_expression }
		'unsafe_expression' { NodeType.unsafe_expression }
		'variadic_type' { NodeType.variadic_type }
		'escape_sequence' { NodeType.escape_sequence }
		'false' { NodeType.false_ }
		'field_identifier' { NodeType.field_identifier }
		'float_literal' { NodeType.float_literal }
		'identifier' { NodeType.identifier }
		'import_path' { NodeType.import_path }
		'int_literal' { NodeType.int_literal }
		'label_name' { NodeType.label_name }
		'module_identifier' { NodeType.module_identifier }
		'none' { NodeType.none_ }
		'rune_literal' { NodeType.rune_literal }
		'true' { NodeType.true_ }
		'type_identifier' { NodeType.type_identifier }
		'type_placeholder' { NodeType.type_placeholder }
		 else { NodeType.unknown }
	}
}
