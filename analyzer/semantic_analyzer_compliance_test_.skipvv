import os
import ast
import analyzer { Collector, SemanticAnalyzer, Store, SymbolAnalyzer, new_tree_cursor, setup_builtin }
import benchmark
import v.util { formatted_error }
import v.token { Pos }
import term

fn clean_line_endings(s string) string {
	mut res := s.trim_space()
	res = res.replace(' \n', '\n')
	res = res.replace(' \r\n', '\n')
	res = res.replace('\r\n', '\n')
	res = res.trim('\n')
	return res
}

const skipped_tests = [
	'vlib/v/checker/tests/add_op_wrong_type_err.vv', // AST generated by tree-sitter is invalid
	'vlib/v/checker/tests/a_test_file_with_0_test_fns_test.vv', // TODO: does not support analyzing function names yet
	'vlib/v/checker/tests/ambiguous_field_method_err.vv', // lack unused variable analysis
	'vlib/v/checker/tests/ambiguous_function_call.vv', // lack ambiguous call analysis
	'vlib/v/checker/tests/anon_fn_arg_type_err.vv', // lack undefined ident and unused parameter analysis
	'vlib/v/checker/tests/any_int_float_ban_err.vv', // lack int_literal and float_literal type analysis
	'vlib/v/checker/tests/array_builtin_redefinition.vv',
	'vlib/v/checker/tests/arrow_op_wrong_right_type_err_b.vv' // receive statement analysis not implemented
	'vlib/v/checker/tests/array_cmp_err.vv',
	'vlib/v/checker/tests/array_declare_element_a.vv'
	'vlib/v/checker/tests/array_declare_element_b.vv'
	'vlib/v/checker/tests/array_declare_element_c.vv'
	'vlib/v/checker/tests/array_element_type.vv'
	'vlib/v/checker/tests/array_filter_fn_err.vv'
	'vlib/v/checker/tests/array_index.vv'
	'vlib/v/checker/tests/array_insert_prepend_args_err.vv'
	'vlib/v/checker/tests/array_insert_type_mismatch.vv'
	'vlib/v/checker/tests/array_literal_modify_err.vv'
	'vlib/v/checker/tests/asm_immutable_err.vv' // asm node is loosely parsed
	'vlib/v/checker/tests/assert_optional_err.vv' // error in when importing `os.truncate`
	// 'vlib/v/checker/tests/assign_array_init_with_no_type.vv'
]

// test_analyzer_from_v compares the output from V's checker to VLS' analyzer
fn test_analyzer_from_v() ? {
	mut p := ast.new_parser()
	os.chdir(os.dir(@VEXE)) ?

	input_file_paths := os.glob('vlib/v/checker/tests/*.vv') ?
	out_file_paths := os.glob('vlib/v/checker/tests/*.out') ?

	vlib_path := os.join_path(os.getwd(), 'vlib')
	mut reporter := &Collector{}
	mut store := &Store{
		reporter: reporter
		default_import_paths: [vlib_path, os.vmodules_dir()]
	}

	setup_builtin(mut store, os.join_path(vlib_path, 'builtin'))

	mut sym_analyzer := SymbolAnalyzer{
		store: store
		is_test: true
	}

	mut semantic_analyzer := SemanticAnalyzer{
		store: store
	}

	mut bmark := benchmark.new_benchmark()
	bmark.set_total_expected_steps(input_file_paths.len)

	vv_ext_len := '.vv'.len
	out_ext_len := '.out'.len

	for i in 0 .. input_file_paths.len {
		bmark.step()

		input_file_path := input_file_paths[i]
		out_file_path := out_file_paths[i]
		if input_file_path in skipped_tests {
			println(bmark.step_message_skip(input_file_path))
			continue
		}

		if input_file_path[.. input_file_path.len - vv_ext_len] != out_file_path[.. out_file_path.len - out_ext_len] {
			println(bmark.step_message_fail('file $input_file_path does not have a corresponding output file'))
			break
		}

		modules_dir := os.join_path(os.dir(input_file_path), 'modules')
		input_file_content := os.read_file(input_file_path) ?
		out_file_content := clean_line_endings(os.read_file(out_file_path) ?)

		input_file_runes := input_file_content.runes()
		tree := p.parse_string(source: input_file_content)
		file_name := os.base(input_file_path)
		cursor := new_tree_cursor(tree.root_node())

		store.set_active_file_path(input_file_path, 1)
		store.import_modules_from_tree(tree, input_file_runes)
		store.cleanup_imports()

		sym_analyzer.src_text = input_file_runes
		sym_analyzer.cursor = cursor

		semantic_analyzer.src_text = input_file_runes
		semantic_analyzer.cursor = cursor

		sym_analyzer.analyze()
		semantic_analyzer.analyze()

		formatted_messages := clean_line_endings(reporter.errors.map(
			term.strip_ansi(formatted_error('error:', it.message, it.file_path, Pos{
				len: int(it.range.end_byte - it.range.start_byte)
				line_nr: int(it.range.start_point.row)
				col: int(it.range.start_point.column)
			}))
		).join('\n'))

		if file_name.starts_with('array_') && out_file_content != formatted_messages {
			println(bmark.step_message_skip(input_file_path))
		} else if out_file_content != formatted_messages {
			eprintln(bmark.step_message_fail(input_file_path))
			assert out_file_content == formatted_messages
		} else {
			assert out_file_content == formatted_messages
			println(bmark.step_message_ok(input_file_path))
		}

		reporter.clear()
		unsafe {
			input_file_content.free()
			tree.raw_tree.free()
			store.opened_scopes[input_file_path].free()
		}
		store.opened_scopes.delete(input_file_path)
		store.delete(os.dir(input_file_path))
	}

	bmark.stop()
	assert bmark.nfail == 0
} 